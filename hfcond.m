function varargout          = hfcond(temp, H, Cl, NH4, vol_frac, hfcp, temp_uncert, H_uncert, Cl_uncert, NH4_uncert)
% HFCOND Temperature- and chemistry-dependent high-frequency conductivity of meteoric polar ice.
% 
%   CONDUCT = HFCOND(TEMP,H,CL,NH4,VOL_FRAC,HFCP) predicts the
%   high-frequency (HF) conductivity of polar ice based on an empirical
%   model. TEMP is temperature (K). H, CL and NH4 are the ice-lattice
%   molarities of acid ([H+]), chloride ([Cl-]) and ammonium ([NH4+])
%   (mol/L). VOL_FRAC is the ice-volume fraction, i.e. the dimensionless
%   ratio of the ice sample's density to that of pure ice. HFCP is a
%   structure containing the dielectric properties necessary for HFCOND
%   generated by HFCONDPROP.
%   
%   [CONDUCT_PURE,CONDUCT_H,CONDUCT_CL,CONDUCT_NH4] = HFCOND(...) returns
%   the separated conductivity contributions from pure ice (CONDUCT_PURE),
%   H+ (CONDUCT_H), Cl- (CONDUCT_CL) and NH4+ (CONDUCT_NH4).
%   
%   [CONDUCT,CONDUCT_PURE,CONDUCT_H,CONDUCT_H,CONDUCT_NH4] = HFCOND(...)
%   returns the total conductivity and its separated contributions.
%   
%   [CONDUCT,CONDUCT_UNCERT] = HFCOND(TEMP,H,CL,NH4,VOL_FRAC,HFCP,H_UNCERT,CL_UNCERT,NH4_UNCERT) 
%   also calculates the uncertainty of the predicted conductivity, which
%   requires the uncertainties H_UNCERT, CL_UNCERT and NH4_UNCERT of the
%   impurity concetrations (mol/L).
%   
%   [CONDUCT,CONDUCT_UNCERT,CONDUCT_PURE,CONDUCT_H,CONDUCT_CL,CONDUCT_NH4] = HFCOND(...)
%   returns the total conductivity, its uncertainty and its separated
%   components.
%   
%   This function follows Equations 1 and 3 and section 2 of the following
%   publication:
%   
%   MacGregor, J.A., D.P. Winebrenner, H. Conway, K. Matsuoka, P.A.
%   Mayewski and G.D. Clow, 2007, Modeling englacial radar attenuation at
%   Siple Dome, West Antarctica, using ice chemistry and temperature data,
%   J. Geophys. Res., 112, F02008
%   
%   (1) conduct = conduct_pure * exp((activ_energy_pure / boltzmann) * ((1 / temp_ref) - (1 / temp))) + 
%                 molar_conduct_H * [H+] * exp((activ_energy_H / boltzmann) * ((1 / temp_ref) - (1 / temp))) +
%                 molar_conduct_Cl * [Cl-] * exp((activ_energy_Cl / boltzmann) * ((1 / temp_ref) - (1 / temp))) +
%                 molar_conduct_NH4 * [NH4+] * exp((activ_energy_NH4 / boltzmann) * ((1 / temp_ref) - (1 / temp))) +
%   
%   (3) standard propagation of error
%   
%   Density corrections for HF conductivity are calculated following
%   Equation 27 of the following publication:
%   
%   Barnes, P.R.F, E.W. Wolff, R. Mulvaney, R. Udisti, E. Castellano, R.
%   Rothlisberger and J.-P. Steffensen, 2002, Effect of density on
%   electrical conductivity of chemically laden polar ice, J. Geophys.
%   Res., 107(B2), 2029
%   
%   (27) conduct_pure(vol_frac) = conduct_pure * vol_frac * ((0.68 + (0.32 * vol_frac)) ^ 2)
%        conduct_H(vol_frac) = molar_conduct_H * H * 1.21 * ((vol_frac - 0.075) ^ 2)
%   
%   The density correction for Cl- and NH4+ is assumed to be the same as that
%   of H+, which deviates slightly from MacGregor et al. [2007].
%   
%   See also HFCONDPROP and ATTEN.
%   
% Joe MacGregor, joemac@ig.utexas.edu
% Last updated: 02/25/15

if ~any(nargin == [6 10])
    error('hfcond:nargin', 'Incorrect number of inputs (must be 6 or 10).')
end
if (~isnumeric(temp) || ~isvector(temp) || any(temp <= 0))
    error('hfcond:temp', 'TEMP must be a numeric positive vector.')
end
if (~isnumeric(H) || ~isvector(H) || any(H < 0))
    error('hfcond:H', 'H must be a numeric positive vector.')
end
if (~isnumeric(Cl) || ~isvector(Cl) || any(Cl < 0))
    error('hfcond:cl', 'CL must be a numeric positive vector.')
end
if (~isnumeric(NH4) || ~isvector(NH4) || any(NH4 < 0))
    error('hfcond:nh4', 'NH4 must be a numeric positive vector.')
end
if (~isnumeric(vol_frac) || ~isvector(vol_frac) || any(vol_frac <= 0) || any(vol_frac > 1))
    error('hfcond:vol_frac', 'VOL_FRAC must be a numeric positive vector >0 and <=1.')
end
if ~isequal(size(H), size(Cl), size(NH4), size(vol_frac))
    error('hfcond:lengths', 'Lengths of H, CL, NH4 and VOL_FRAC must be the same.')
end
if ~isstruct(hfcp)
    error('hfcond:hfcp', 'HFCP is not a structure.')
end
if (nargin == 10)
    if (~isnumeric(temp_uncert) || ~isvector(temp_uncert) || any(temp_uncert < 0))
        error('hfcond:temp_uncert', 'TEMP_UNCERT must be a numeric positive vector.')
    end
    if (~isnumeric(H_uncert) || ~isvector(H_uncert) || any(H_uncert < 0))
        error('hfcond:h_uncert', 'H_UNCERT must be a numeric positive vector.')
    end
    if (~isnumeric(Cl_uncert) || ~isvector(Cl_uncert) || any(Cl_uncert < 0))
        error('hfcond:cl_uncert', 'CL_UNCERT must be a numeric positive vector.')
    end
    if (~isnumeric(NH4_uncert) || ~isvector(NH4_uncert) || any(NH4_uncert < 0))
        error('hfcond:nh4_uncert', 'NH4_UNCERT must be a numeric positive vector.')
    end
    if ~isequal(size(H), size(temp_uncert), size(H_uncert), size(Cl_uncert), size(NH4_uncert))
        error('hfcond:lengths_uncert', 'Lengths of H, Cl, NH4, TEMP_UNCERT, H_UNCERT, Cl_UNCERT and NH4_UNCERT must be the same.')
    end
    if ~any(nargout == [2 6])
        warning('hfcond:uncert_match', 'H_UNCERT, CL_UNCERT and NH4_UNCERT are inputted but CONDUCT_UNCERT is not requested an output.')
    end
end
if ~any(nargout == [0:2 4:6])
    error('hfcond:nargout', 'Too many outputs (must be 0, 1, 2, 4, 5 or 6).')
end

boltzmann                   = 1.3806503e-23; % Boltzmann constant, m^2 kg s^-2
conv_eV_J                   = 1.60217646e-19; % J/eV

% convert activation energies from eV to J
[hfcp.activ_energy_pure, hfcp.activ_energy_H, hfcp.activ_energy_Cl, hfcp.activ_energy_pure_uncert, hfcp.activ_energy_H_uncert, hfcp.activ_energy_Cl_uncert, hfcp.activ_energy_NH4, hfcp.activ_energy_NH4_uncert] ...
                            = deal((conv_eV_J * hfcp.activ_energy_pure), (conv_eV_J * hfcp.activ_energy_H), (conv_eV_J * hfcp.activ_energy_Cl), (conv_eV_J * hfcp.activ_energy_pure_uncert), (conv_eV_J * hfcp.activ_energy_H_uncert), (conv_eV_J * hfcp.activ_energy_Cl_uncert), ...
                                   (conv_eV_J * hfcp.activ_energy_NH4), (conv_eV_J * hfcp.activ_energy_NH4));

% calculate uncertainty based on number of inputs
if (nargin == 10)
    do_uncert               = true;
else
    do_uncert               = false;
end

% correct for pre-melting if desired/necessary
if (hfcp.do_premelt && any(temp >= hfcp.temp_premelt))
    hfcp.molar_conduct_H = hfcp.molar_conduct_H .* ones(size(temp));
    hfcp.molar_conduct_H(temp >= hfcp.temp_premelt) ...
                            = hfcp.molar_conduct_H(temp >= hfcp.temp_premelt) .* exp((hfcp.activ_energy_H / boltzmann) * ((1 / hfcp.temp_premelt) - (1 / hfcp.temp_ref)) * (hfcp.fact_premelt - 1)); % correct molar_conduct_H so that there is no discontinuity at hfcp.temp_premelt
    hfcp.activ_energy_H  = hfcp.activ_energy_H .* ones(size(temp));
    hfcp.activ_energy_H(temp >= hfcp.temp_premelt) ...
                            = hfcp.activ_energy_H(temp >= hfcp.temp_premelt) .* hfcp.fact_premelt; % increase hfcp.activ_energy_H
    if do_uncert
        hfcp.activ_energy_H_uncert ...
                            = hfcp.activ_energy_H_uncert .* ones(size(temp));
        hfcp.activ_energy_H_uncert(temp >= hfcp.temp_premelt) ...
                            = hfcp.activ_energy_H_uncert(temp >= hfcp.temp_premelt) .* hfcp.fact_premelt; % increase hfcp.activ_energy_H
    end
end

% individual conductivity contributions
conduct_pure                = hfcp.conduct_pure .* exp((hfcp.activ_energy_pure / boltzmann) .* ((1 / hfcp.temp_ref) - (1 ./ temp)));
conduct_H                   = (hfcp.molar_conduct_H .* H) .* exp((hfcp.activ_energy_H ./ boltzmann) .* ((1 / hfcp.temp_ref) - (1 ./ temp)));
conduct_Cl                  = (hfcp.molar_conduct_Cl .* Cl) .* exp((hfcp.activ_energy_Cl / boltzmann) .* ((1 / hfcp.temp_ref) - (1 ./ temp)));
conduct_NH4                 = (hfcp.molar_conduct_NH4 .* NH4) .* exp((hfcp.activ_energy_NH4 / boltzmann) .* ((1 / hfcp.temp_ref) - (1 ./ temp)));

% conductivity uncertainty
if do_uncert
    % convenient terms from standard error propagation for each component of conductivity model
    exp_pure                = exp(((2 * hfcp.activ_energy_pure) / boltzmann) .* ((1 / hfcp.temp_ref) - (1 ./ temp)));
    exp_H                   = exp(((2 * hfcp.activ_energy_H) ./ boltzmann) .* ((1 / hfcp.temp_ref) - (1 ./ temp)));
    exp_Cl                  = exp(((2 * hfcp.activ_energy_Cl) / boltzmann) .* ((1 / hfcp.temp_ref) - (1 ./ temp)));
    exp_NH4                 = exp(((2 * hfcp.activ_energy_NH4) / boltzmann) .* ((1 / hfcp.temp_ref) - (1 ./ temp)));
    temp_k                  = (((1 / hfcp.temp_ref) - (1 ./ temp)) ./ boltzmann) .^ 2;
    % sum of each derivative from standard error propagation
    conduct_pure_uncert     = ((hfcp.conduct_pure_uncert ^ 2) .* exp_pure) + (((hfcp.activ_energy_pure_uncert * hfcp.conduct_pure) ^ 2) .* temp_k .* exp_pure);
    conduct_H_uncert        = (((H_uncert * hfcp.molar_conduct_H) .^ 2) .* exp_H) + (((hfcp.molar_conduct_H_uncert .* H) .^ 2) .* exp_H) + (((hfcp.activ_energy_H_uncert .* hfcp.molar_conduct_H .* H) .^ 2) .* temp_k .* exp_H);
    conduct_Cl_uncert       = (((Cl_uncert * hfcp.molar_conduct_Cl) ^ 2) .* exp_Cl) + (((hfcp.molar_conduct_Cl_uncert .* Cl) .^ 2) .* exp_Cl) + (((hfcp.activ_energy_Cl_uncert .* hfcp.molar_conduct_Cl .* Cl) .^ 2) .* temp_k .* exp_Cl);
    conduct_NH4_uncert      = (((NH4_uncert * hfcp.molar_conduct_NH4) ^ 2) .* exp_NH4) + (((hfcp.molar_conduct_NH4_uncert .* NH4) .^ 2) .* exp_NH4) + (((hfcp.activ_energy_NH4_uncert .* hfcp.molar_conduct_NH4 .* NH4) .^ 2) .* temp_k .* exp_NH4);
    conduct_temp_pure_uncert= (temp_uncert .^ 2) .* (((((hfcp.conduct_pure * hfcp.activ_energy_pure) / boltzmann) ./ (temp .^ 2)) .^ 2) .* exp_pure);
    conduct_temp_imp_uncert = (temp_uncert .^ 2) .* ((((((hfcp.molar_conduct_H * hfcp.activ_energy_H) / boltzmann) .* (H ./ (temp .^ 2))) .^ 2) .* exp_H) + (((((hfcp.molar_conduct_Cl * hfcp.activ_energy_Cl) / boltzmann) .* (Cl ./ (temp .^ 2))) .^ 2) .* exp_Cl) + ...
                              (((((hfcp.molar_conduct_NH4 * hfcp.activ_energy_NH4) / boltzmann) .* (NH4 ./ (temp .^ 2))) .^ 2) .* exp_NH4));
end

% correct for eutectic temperature of Cl if requested/necessary
if (hfcp.do_eutectic_Cl && any(temp < hfcp.temp_eutectic_Cl))
    conduct_Cl(temp < hfcp.temp_eutectic_Cl) ...
                            = 0;
    if do_uncert
        conduct_Cl_uncert(temp < hfcp.temp_eutectic_Cl) ...
                            = 0;
    end
end

% correct for density if necessary
if any(vol_frac ~= 1)
    conduct_pure            = conduct_pure .* vol_frac .* ((0.68 + (0.32 .* vol_frac)) .^ 2);
    conduct_H               = conduct_H .* 1.21 .* ((vol_frac - 0.075) .^ 2.5);
    conduct_Cl              = conduct_Cl .* 1.21 .* ((vol_frac - 0.075) .^ 2.5);
    conduct_NH4             = conduct_NH4 .* 1.21 .* ((vol_frac - 0.075) .^ 2.5);
    if do_uncert
        conduct_pure_uncert = conduct_pure_uncert .* vol_frac .* ((0.68 + (0.32 .* vol_frac)) .^ 2);
        conduct_H_uncert    = conduct_H_uncert .* 1.21 .* ((vol_frac - 0.075) .^ 2.5);
        conduct_Cl_uncert   = conduct_Cl_uncert .* 1.21 .* ((vol_frac - 0.075) .^ 2.5);
        conduct_NH4_uncert  = conduct_NH4_uncert .* 1.21 .* ((vol_frac - 0.075) .^ 2.5);
        conduct_temp_pure_uncert ...
                            = conduct_temp_pure_uncert .* vol_frac .* ((0.68 + (0.32 .* vol_frac)) .^ 2);
        conduct_temp_imp_uncert ...
                            = conduct_temp_imp_uncert .* 1.21 .* ((vol_frac - 0.075) .^ 2.5);
    end
end

% total conductivity and uncertainty
conduct                     = conduct_pure + conduct_H + conduct_Cl + conduct_NH4;
if do_uncert
    conduct_uncert          = sqrt(conduct_pure_uncert + conduct_H_uncert + conduct_Cl_uncert + conduct_NH4_uncert + conduct_temp_pure_uncert + conduct_temp_imp_uncert);
end

% returned conductivities based on nargout
switch nargout
    case {0 1}
        varargout{1}        = conduct;
    case 2
        [varargout{1}, varargout{2}] ...
                            = deal(conduct, conduct_uncert);
    case 4
        [varargout{1}, varargout{2}, varargout{3}, varargout{4}] ...
                            = deal(conduct_pure, conduct_H, conduct_Cl, conduct_NH4);
    case 5
        [varargout{1}, varargout{2}, varargout{3}, varargout{4}, varargout{5}] ...
                            = deal(conduct, conduct_pure, conduct_H, conduct_Cl, conduct_NH4);
    case 6
        [varargout{1}, varargout{2}, varargout{3}, varargout{4}, varargout{5}, varargout{6}] ...
                            = deal(conduct, conduct_uncert, conduct_pure, conduct_H, conduct_Cl, conduct_NH4);
end