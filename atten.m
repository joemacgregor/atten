function varargout          = atten(thick, depth_inc, temp, H, Cl, NH4, vol_frac, hfcp, return_type, temp_uncert, H_uncert, Cl_uncert, NH4_uncert)
% ATTEN Temperature-, chemistry- and density-dependent englacial radar-attenuation rate.
%   
%   N_MEAN = ATTEN(THICK,DEPTH_INC,TEMP,H,CL,NH4,VOL_FRAC,HFCP) predicts
%   the depth-averaged radar-attenuation rate N_MEAN (dB/km) through an ice
%   column of thickness THICK (m). DEPTH_INC is a vector with thickness of
%   each layer (m) for which the attenuation-rate profile is to be
%   calculated. TEMP is the temperature (K) of the entire ice column or
%   each layer. H, CL and NH4 are the englacial molarities of acid ([H+]),
%   chloride ([Cl-]) and ammonium ([NH4+]) in mol/L (M), respectively, and
%   they can either be scalars, representing the thickness-averaged value,
%   or vectors whose values correspond to those for each layer whose
%   thickness is given by DEPTH_INC. Similarly, VOL_FRAC is the ice-volume
%   fraction of each layer, i.e. the dimensionless ratio of the layer
%   density to that of pure ice. HFCP is a structure containing the
%   dielectric properties to be used by HFCOND that is generated by
%   HFCONDPROP.
%   
%   [N_MEAN,N_PROF] = ATTEN(...) also returns the predicted attenuation-rate
%   depth profile N_PROF.
%   
%   [...] = ATTEN(..., RETURN_TYPE) affects both the inputs to and outputs
%   from ATTEN. RETURN_TYPE must be set to either 'std' (default), 'uncert'
%   or 'sep'.
%       'std'       Standard calculation using default model parameters.
%       'uncert'    Also calcluate the uncertainty in the predicted
%                   attenuation-rates. This choice requires four additional
%                   inputs, which are the uncertainties in temperature and
%                   the impurity molarities H_UNCERT, CL_UNCERT and
%                   NH4_UNCERT. The second element of N_MEAN is its
%                   uncertainty and the remaining columns of N_PROF are
%                   prediction +/- its standard deviation, respectively.
%       'sep'       Separates the returned attenuation-rate predictions by
%                   contribution (pure ice and impurities). The first
%                   element N_MEAN is the pure ice contribution, and the
%                   remaining elements are the impurity contributions,
%                   respectively, and the remaining columns of N_PROF
%                   follow the same pattern.
%   
%   This function follows Equations 10 and 11 of the following
%   publication:
%   
%   MacGregor, J.A., D.P. Winebrenner, H. Conway, K. Matsuoka, P.A.
%   Mayewski and G.D. Clow, 2007, Modeling englacial radar attenuation at
%   Siple Dome, West Antarctica, using ice chemistry and temperature data,
%   J. Geophys. Res., 112, F02008
%   
%   (10) atten = 1000 * (10 * log10(exp(1))) / length_atten
%   (11) atten(depth) = (1 / depth) * sum(atten(depth_inc) * depth_inc)
%   
%   Note that Equation 10 of the above publication has a coefficient error
%   for the units given and was corrected in Equation 1 of the following
%   publication:
%   
%   MacGregor, J.A., K. Matsuoka, E.D. Waddington, D.P. Winebrenner and F.
%   Pattyn, 2012, Spatial variation of englacial radar attenuation:
%   Modeling approach and application to the Vostok flowline, J. Geophys.
%   Res., 117, F03022
%   
%   (1) atten = ((10 * log10(exp(1))) / (1000 * permitt_vacuum * sqrt(permitt_ice) * speed_light)) * conduct
%   
%   ATTEN requires that that HFCOND and LOOYENGA be available within the
%   user's path.
%   
%   See also HFCOND, HFCONDPROP and LOOYENGA.
% 
% Joe MacGregor (joseph.a.macgregor@nasa.gov)
% Last updated: 14 January 2025

if ~any(nargin == [8 9 13])
    error('atten:nargin', 'Incorrect number of inputs (must be 8, 9 or 13).')
end
if ~exist('hfcond', 'file')
    error('atten:hfcond', 'Function HFCOND is not available within this user''s path.')
end
if ~exist('looyenga', 'file')
    error('atten:looyenga', 'Function LOOYENGA is not available within this user''s path.')
end
if (~isnumeric(thick) || length(thick) > 1)
    error('atten:thick', 'THICK must be a scalar.')
end
if (~isnumeric(depth_inc) || ~isvector(depth_inc))
    error('atten:depth_inc', 'DEPTH_INC must be a numeric vector.')
end
if (~isnumeric(temp) || ~isvector(temp))
    error('atten:temp', 'TEMP must be a numeric vector.')
end
if (~isnumeric(H) || ~isvector(H))
    error('atten:H', 'H must be a numeric vector.')
end
if (~isnumeric(Cl) || ~isvector(Cl))
    error('atten:Cl', 'CL must be a numeric vector.')
end
if (~isnumeric(NH4) || ~isvector(NH4))
    error('atten:NH4', 'NH4 must be a numeric vector.')
end
if (~isnumeric(vol_frac) || ~isvector(vol_frac))
    error('atten:vol_frac', 'VOL_FRAC must be a numeric vector.')
end
if ~isequal(size(depth_inc), size(temp))
    error('atten:lengths1', 'Lengths of DEPTH_INC and TEMP must be the same.')
end
if ~isequal(size(H), size(Cl), size(NH4), size(vol_frac))
    error('atten:lengths2', 'Sizes of H, CL, NH4 and VOL_FRAC must be the same.')
end
if ~isstruct(hfcp)
    error('atten:hfcp', 'HFCP is not a structure.')
end
if (nargin == 8)
    return_type             = 'std';
end
if ~ischar(return_type)
    error('atten:return_type1', 'RETURN_TYPE must be a string.')
end
if ~any(strcmp(return_type, {'std' 'uncert' 'sep'}))
    error('atten:return_type2', 'RETURN_TYPE must be set to either ''std'', ''uncert'' or ''sep''.')
end
if strcmp(return_type, 'uncert')
    if (nargin ~= 13)
        error('atten:uncerts', 'TEMP_UNCERT, H_UNCERT, CL_UNCERT and NH4_UNCERT must be provided if RETURN_TYPE is set to ''uncert''.')
    end
    if (~isnumeric(temp_uncert) || ~isvector(temp_uncert))
        error('atten:temp_uncert', 'TEMP_UNCERT must be a numeric vector.')
    end
    if (~isnumeric(H_uncert) || ~isvector(H_uncert))
        error('atten:H_uncert', 'H_UNCERT must be a numeric vector.')
    end
    if (~isnumeric(Cl_uncert) || ~isvector(Cl_uncert))
        error('atten:Cl_uncert', 'CL_UNCERT must be a numeric vector.')
    end
    if (~isnumeric(NH4_uncert) || ~isvector(NH4_uncert))
        error('atten:NH4_uncert', 'NH4_UNCERT must be a numeric vector.')
    end
    if ~isequal(size(H), size(temp_uncert), size(H_uncert), size(Cl_uncert), size(NH4_uncert))
        error('atten:lengths_uncert', 'Lengths of TEMP_UNCERT, H_UNCERT, CL_UNCERT, NH4_UNCERT must be the same as TEMP, H, CL and NH4.')
    end
end
if (nargout > 2)
    error('atten:nargout', 'Incorrect number of outputs (up to 2).')
end

% column vector check
col_var                     = {'depth_inc' 'temp', 'H' 'Cl' 'NH4' 'vol_frac'};
if strcmp(return_type, 'uncert')
    col_var                 = [col_var 'temp_uncert' 'H_uncert' 'Cl_uncert' 'NH4_uncert'];
end
for ii = 1:length(col_var)
    if isrow(eval(col_var{ii}))
        eval([col_var{ii} ' = ' col_var{ii} ''';'])
    end
end

% HF conductivity, S/m
switch return_type
    case 'std'
        conduct             = hfcond(temp, H, Cl, NH4, vol_frac, hfcp);
    case 'uncert'
        [conduct, conduct_uncert] ...
                            = hfcond(temp, H, Cl, NH4, vol_frac, hfcp, temp_uncert, H_uncert, Cl_uncert, NH4_uncert);
    case 'sep'
        [conduct_pure, conduct_H, conduct_Cl, conduct_NH4] ...
                            = hfcond(temp, H, Cl, NH4, vol_frac, hfcp);
end

permitt_vacuum              = 8.85418782e-12; % permittivity of free space, F/m
speed_light                 = 299792458; % speed of light in the vacuum, m/s
cond_atten_conv             = (1e4 * log10(exp(1))) ./ (sqrt(looyenga(vol_frac, (hfcp.permitt_ice .* ones(size(vol_frac))), ones(size(vol_frac)))) .* (permitt_vacuum * speed_light)); % (dB/km*M)
                              % conversion between HF conductivity and radar-attenuation rate based on Equations 9 and 10 in MacGregor et al. [2007, 2012]
                              % note that Equation 1 of MacGregor et al. [2012] assumes uS/m, but cond_atten_conv assumes S/m, following Equation 10 of MacGregor et al. [2007]

% attenuation rate, dB/km
switch return_type
    case 'std'
        atten_set           = cond_atten_conv .* conduct; % main attenuation rate set
        atten_rate          = sum(atten_set .* depth_inc) / thick; % depth-averaged attenuation rate
    case 'uncert'
        atten_std           = cond_atten_conv .* conduct;
        atten_rate          = sum(atten_std .* depth_inc) / thick;
        atten_min           = cond_atten_conv .* (conduct - conduct_uncert); % low value using uncertainty
        atten_rate_min      = sum(atten_min .* depth_inc) / thick;
        atten_max           = cond_atten_conv .* (conduct + conduct_uncert); % high value using uncertainty
        atten_set           = [atten_std atten_min atten_max]; % attenuation rate profiles with low and high range
        atten_rate          = [atten_rate (atten_rate - atten_rate_min)]; % depth-averaged attenuation rates with uncertainty
    case 'sep'
        atten_pure          = cond_atten_conv .* conduct_pure; % pure ice attenuation rate set
        atten_rate_pure     = sum(atten_pure .* depth_inc) / thick; % pure ice depth-averaged attenuation rate
        atten_H             = cond_atten_conv .* conduct_H;
        atten_rate_H        = sum(atten_H .* depth_inc) / thick;
        atten_Cl            = cond_atten_conv .* conduct_Cl;
        atten_rate_Cl       = sum(atten_Cl .* depth_inc) / thick;
        atten_NH4           = cond_atten_conv .* conduct_NH4;
        atten_rate_NH4      = sum(atten_NH4 .* depth_inc) / thick;
        atten_set           = [atten_pure atten_H atten_Cl atten_NH4];
        atten_rate          = [atten_rate_pure atten_rate_H atten_rate_Cl atten_rate_NH4];
end

% return either just the depth-averaged values or the depth profiles also
switch nargout
    case {0 1}
        varargout{1}        = atten_rate;
    case 2
        [varargout{1}, varargout{2}] ...
                            = deal(atten_rate, atten_set);
end